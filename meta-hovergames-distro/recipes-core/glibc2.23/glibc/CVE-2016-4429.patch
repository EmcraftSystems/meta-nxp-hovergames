From 5b46879d7f74b8c9d3c95d39063d78846e7ce391 Mon Sep 17 00:00:00 2001
From: Florian Weimer <fweimer@redhat.com>
Date: Mon, 23 May 2016 20:18:34 +0200
Subject: [PATCH] CVE-2016-4429: sunrpc: Do not use alloca in clntudp_call [BZ
 #20112]

The call is technically in a loop, and under certain circumstances
(which are quite difficult to reproduce in a test case), alloca
can be invoked repeatedly during a single call to clntudp_call.
As a result, the available stack space can be exhausted (even
though individual alloca sizes are bounded implicitly by what
can fit into a UDP packet, as a side effect of the earlier
successful send operation).

Upstream-Status: Backport
CVE: CVE-2016-4429

Signed-off-by: Armin Kuster <akuster@mvsita.com>

---
 ChangeLog         |  7 +++++++
 NEWS              |  4 ++++
 sunrpc/clnt_udp.c | 10 +++++++++-
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/ChangeLog b/ChangeLog
index 954ff2a389..71b7c327ab 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,10 @@
+2016-05-23  Florian Weimer  <fweimer@redhat.com>
+
+   CVE-2016-4429
+   [BZ #20112]
+   * sunrpc/clnt_udp.c (clntudp_call): Use malloc/free for the error
+   payload.
+
 2016-04-29  Florian Weimer  <fweimer@redhat.com>
 
    [BZ #20010]
diff --git a/NEWS b/NEWS
index 6d0404b3f3..4b37612fb9 100644
--- a/NEWS
+++ b/NEWS
@@ -110,6 +110,10 @@ Security related changes:
   reporting the security impact of this issue, and Robert Holiday of
   Ciena for reporting the related bug 18665. (CVE-2015-7547)
 
+* The Sun RPC UDP client could exhaust all available stack space when
+  flooded with crafted ICMP and UDP messages.  Reported by Aldy Hernandez'
+  alloca plugin for GCC.  (CVE-2016-4429)
+
 The following bugs are resolved with this release:
 
   [89] localedata: Locales nb_NO and nn_NO should transliterate æøå
diff --git a/sunrpc/clnt_udp.c b/sunrpc/clnt_udp.c
index a6cf5f1ca7..4d9acb1e6a 100644
--- a/sunrpc/clnt_udp.c
+++ b/sunrpc/clnt_udp.c
@@ -388,9 +388,15 @@ send_again:
 	  struct sock_extended_err *e;
 	  struct sockaddr_in err_addr;
 	  struct iovec iov;
-	  char *cbuf = (char *) alloca (outlen + 256);
+	  char *cbuf = malloc (outlen + 256);
 	  int ret;
 
+	  if (cbuf == NULL)
+	    {
+	      cu->cu_error.re_errno = errno;
+	      return (cu->cu_error.re_status = RPC_CANTRECV);
+	    }
+
 	  iov.iov_base = cbuf + 256;
 	  iov.iov_len = outlen;
 	  msg.msg_name = (void *) &err_addr;
@@ -415,10 +421,12 @@ send_again:
 		 cmsg = CMSG_NXTHDR (&msg, cmsg))
 	      if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR)
 		{
+		  free (cbuf);
 		  e = (struct sock_extended_err *) CMSG_DATA(cmsg);
 		  cu->cu_error.re_errno = e->ee_errno;
 		  return (cu->cu_error.re_status = RPC_CANTRECV);
 		}
+	  free (cbuf);
 	}
 #endif
       do
